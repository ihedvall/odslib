/*
 * Copyright 2022 Ingemar Hedvall
 * SPDX-License-Identifier: MIT
 */

#include <filesystem>
#include <algorithm>
#include <ranges>

#include "ods/itable.h"
#include "ods/imodel.h"
#include "util/ixmlfile.h"
#include "util/logstream.h"
#include "util/timestamp.h"
using namespace util::xml;
using namespace util::log;
using namespace util::time;
using namespace std::chrono;

namespace {
void ReadColumn(const IXmlNode& node, ods::ITable& table) {
  ods::IColumn col;

  if (node.ExistProperty("Name")) {
    col.ApplicationName(node.Property<std::string>("Name"));
  } else {
    col.ApplicationName(node.Attribute<std::string>("name"));
  }

  if (node.ExistProperty("ColumnName")) {
    col.DatabaseName(node.Property<std::string>("ColumnName"));
  } else {
    col.DatabaseName(node.Attribute<std::string>("column"));
  }

  col.Description(node.Property<std::string>("Description"));
  col.DisplayName(node.Property<std::string>("DisplayName"));
  col.BaseName(node.Property<std::string>("BaseName"));
  col.ReferenceName(node.Property<std::string>("RefColumnName"));
  col.DefaultValue(node.Property<std::string>("DefaultValue"));

  col.ReferenceId(node.Property<int64_t>("RefId"));

  const auto* type = node.GetNode("Type");
  if (type != nullptr) {
    col.DataType(ods::TextToDataType(type->Value<std::string>()));
    if (node.ExistProperty("Unit")) {
      col.Unit(node.Property<std::string>("Unit"));
    } else {
      col.Unit(type->Attribute<std::string>("unit"));
    }

    if (node.ExistProperty("EnumName")) {
      col.EnumName(node.Property<std::string>("EnumName"));
    } else {
      col.EnumName(type->Attribute<std::string>("enum"));
    }

    if (node.ExistProperty("Decimals")) {
      col.NofDecimals(node.Property<int>("Decimals", -1));
    } else {
      col.NofDecimals(type->Attribute<int>("decimals", -1));
    }

    if (node.ExistProperty("Length")) {
      col.DataLength(node.Property<size_t>("Length"));
    } else {
      col.DataLength(type->Attribute<int>("length"));
    }
  }

  const auto* flags = node.GetNode("Flags");
  if (flags != nullptr) {
    uint16_t temp = 0;
     if (flags->Attribute<bool>("auto")) {
       temp |= ods::kAutoGenerated;
     }
    if (flags->Attribute<bool>("unique")) {
      temp |= ods::kUnique;
    }
    if (flags->Attribute<bool>("index")) {
      temp |= ods::kIndex;
    }
    if (flags->Attribute<bool>("obligatory")) {
      temp |= ods::kObligatory;
    }
    if (flags->Attribute<bool>("casesensitive")) {
      temp |= ods::kCaseSensitive;
    }
    col.Flags(temp);
  }
  table.AddColumn(col);
}

void SaveEnum(const ods::IEnum& enum1, IXmlNode &root) {
  auto& node = root.AddNode("Enumerate");
  node.SetAttribute("name",enum1.EnumName());
  node.SetAttribute("locked",enum1.Locked());
  const auto& item_list = enum1.Items();
  for (const auto& itr : item_list) {
    auto &item_node = node.AddNode("Item");
    item_node.SetAttribute("number", itr.first);
    item_node.SetAttribute("value", itr.second);
  }
}



void SaveColumn(const ods::IColumn& column, IXmlNode& root) {
  auto& node = root.AddNode("Attribute");
  node.SetAttribute("name", column.ApplicationName());
  if (!column.DatabaseName().empty()) {
    node.SetAttribute("column", column.DatabaseName());
  }
  if (!column.Description().empty()) {
    node.SetProperty("Description", column.Description());
  }
  if (!column.DisplayName().empty()) {
    node.SetProperty("DisplayName", column.DisplayName());
  }
  if (!column.BaseName().empty()) {
    node.SetProperty("BaseName", column.BaseName());
  }
  const auto data_type = column.DataType();
  auto& type = node.AddNode("Type");
  type.Value(ods::DataTypeToText(column.DataType()));
  if (!column.Unit().empty()) {
    type.SetAttribute("unit", column.Unit());
  }
  if (!column.EnumName().empty()) {
    type.SetAttribute("enum", column.EnumName());
  }
  if (column.NofDecimals() >= 0 && (data_type == ods::DataType::DtFloat || data_type == ods::DataType::DtDouble)) {
    type.SetAttribute("decimals", column.NofDecimals());
  }
  if (column.DataLength() > 0) {
    type.SetAttribute("length", column.DataLength());
  }


  if (column.Flags() > 0) {
    auto& flags = node.AddNode("Flags");
    flags.Value(column.Flags());
    if (column.Auto()) {
      flags.SetAttribute("auto", true);
    }
    if (column.Unique()) {
      flags.SetAttribute("unique", true);
    }
    if (column.Index()) {
      flags.SetAttribute("index", true);
    }
    if (column.Obligatory()) {
      flags.SetAttribute("obligatory", true);
    }
    if (column.CaseSensitive()) {
      flags.SetAttribute("casesensitive", true);
    }
  }

  if (column.ReferenceId() > 0) {
    node.SetProperty("RefId", column.ReferenceId());
  }
  if (!column.ReferenceName().empty()) {
    node.SetProperty("RefColumnName", column.ReferenceName());
  }
  if (!column.DefaultValue().empty()) {
    node.SetProperty("DefaultValue", column.DefaultValue());
  }
}

void SaveTable(const ods::ITable& table, IXmlNode &root) {
  auto& node = root.AddNode("Element");
  node.SetAttribute("id", table.ApplicationId());
  node.SetAttribute("name", table.ApplicationName());
  node.SetAttribute("base", BaseIdToText(table.BaseId()));
  if (!table.DatabaseName().empty()) {
    node.SetAttribute("table", table.DatabaseName());
  }
  if (table.ParentId() > 0) {
    node.SetAttribute("parent", table.ParentId());
  }
  if (!table.Description().empty()) {
    node.SetProperty("Description", table.Description());
  }
  if (table.SecurityMode() > 0) {
    node.SetProperty("SecurityMode", table.SecurityMode());
  }

  const auto& column_list = table.Columns();
  for (const auto& column : column_list) {
    SaveColumn(column, node);
  }
}

void AddSubTable(const ods::ITable& table, std::vector<const ods::ITable*>& list) { //NOLINT
  const auto& sub_table_list = table.SubTables();
  for (const auto& itr : sub_table_list) {
    list.push_back(&itr.second);
    AddSubTable(itr.second, list);
  }
}

}
namespace ods {

bool IModel::operator == (const IModel &model) const {
  if (name_ != model.name_) return false;
  if (version_ != model.version_) return false;
  if (description_ != model.description_) return false;
  if (created_by_ != model.created_by_) return false;
  if (modified_by_ != model.modified_by_) return false;
  if (base_version_ != model.base_version_) return false;
  // Skip the created and modified properties.
  if (source_name_ != model.source_name_) return false;
  if (source_type_ != model.source_type_) return false;
  if (source_info_ != model.source_info_) return false;


  const auto table_list = AllTables();
  const auto model_table_list = model.AllTables();

  // Check if any tables added or deleted.
  if (table_list.size() != model_table_list.size() ) return false;

  // Iterate through all tables and check if amy table changed.
  for (const ITable* table : table_list) {
    if (table == nullptr) {
      continue;
    }
    const ITable* model_table = model.GetTable(table->ApplicationId());
    if (model_table == nullptr) {
      return false;
    }
    if (*table != *model_table) {
      return false;
    }
  }

  // Test if any enumeration added or deleted.
  if (enum_list_.size() != model.enum_list_.size() ) {
    return false;
  }

  // Check every enumeration
  for (const auto& [enum_name, enumeration1] : enum_list_) {
    const auto *enumeration2 = GetEnum(enum_name);
    if (enumeration2 == nullptr) {
      return false;
    }
    if (enumeration1 != *enumeration2) {
      return false;
    }
  }

  // Test if any relation added or deleted.
  if (relation_list_.size() != model.relation_list_.size() ) {
    return false;
  }

    // Check every relation
  for (const auto& [relation_name, relation1] : relation_list_) {
    const auto* relation2 = GetRelationByName(relation_name);
    if ( relation2 == nullptr) {
      return false;
    }
    if (relation1 != *relation2) {
      return false;
    }
  }

  return true;
}

void IModel::AddTable(const ITable &table) { //NOLINT
  ITable copy = table;
  const auto old_app_id = copy.ApplicationId();
  if (old_app_id <= 0 || GetTable(old_app_id) != nullptr) {
    copy.ApplicationId(FindNextTableId(copy.ParentId()));
  }
  // Remove all sub-tables and add them later
  auto& table_list = copy.SubTables();
  std::vector<ITable> temp_list;
  temp_list.reserve(table_list.size());
  for (const auto& itr : table_list) {
    temp_list.push_back(itr.second);
  }
  table_list.clear();

  auto* parent = copy.ParentId() != 0 ? const_cast<ITable*>(GetTable(copy.ParentId())) : nullptr;
  if (parent != nullptr) {
    parent->AddSubTable(copy);
  } else {
    table_list_.insert({copy.ApplicationId(), copy});
  }

  // Add all sub-tables again so they get the right references
  for (auto& sub_table : temp_list) {
    sub_table.ParentId(copy.ApplicationId());
    sub_table.ApplicationId(0);
    AddTable(sub_table);
  }

  // Add any missing enumerating
  const auto& column_list = copy.Columns();
  for (const auto& column : column_list) {
    const std::string& enum_name = column.EnumName();
    if (enum_name.empty()) {
      continue;
    }
    const bool exist = GetEnum(enum_name) != nullptr;
    if (exist) {
      continue;
    }
    IEnum def = CreateDefaultEnum(enum_name);
    AddEnum(def);
    LOG_DEBUG() << "Added missing enumerate. Enum: " << enum_name;
  }
}

void IModel::AddEnum(const IEnum& obj) {
  auto itr = enum_list_.find(obj.EnumName());
  if (itr == enum_list_.end()) {
    enum_list_.insert({obj.EnumName(), obj});
  } else {
    itr->second = obj;
  }
}

void IModel::DeleteEnum(const std::string& name) {
  auto itr = enum_list_.find(name);
  if (itr != enum_list_.end()) {
    enum_list_.erase(itr);
  }
}

bool IModel::ReadModel(const std::string &filename) {
  auto xml_file = CreateXmlFile();
  if (!xml_file) {
    LOG_ERROR() << "Failed to create the XML parser. File: " << filename;
    return false;
  }
  xml_file->FileName(filename);
  const auto parse = xml_file->ParseFile();
  if (!parse) {
    LOG_ERROR() << "XML parser error. File: " << filename;
    return false;
  }
  if (xml_file->RootName() != "OdsModel") {
    LOG_ERROR() << "Invalid root tag. Tag: " << xml_file->RootName() << ", File: " << filename;
    return false;
  }
  table_list_.clear();
  enum_list_.clear();
  Name(xml_file->Property("Name",std::string("")));
  if (Name().empty()) {
    try {
      std::filesystem::path file(filename);
      Name(file.stem().string());
    } catch (const std::exception& ) {
    }
  }
  Version(xml_file->Property("ApplicationVersion",std::string("")));
  Description(xml_file->Property("Description",std::string("")));
  CreatedBy(xml_file->Property("CreatedBy",std::string("")));
  ModifiedBy(xml_file->Property("ModifiedBy",std::string("")));
  BaseVersion(xml_file->Property("BaseVersion",std::string("")));

  Created(IsoTimeToNs(xml_file->Property("Created",std::string(""))));
  Modified(IsoTimeToNs(xml_file->Property("Modified",std::string(""))));

  SourceName(xml_file->Property("SourceName",std::string()));
  SourceType(xml_file->Property("SourceType",std::string()));
  SourceInfo(xml_file->Property("SourceInfo",std::string()));

  // A common problem is that the unit and physical dimension tables,
  // not are case-sensitive.
  // Check that the name columns are case-sensitive.
  ITable* unit_table = GetTableByBaseId(BaseId::AoUnit);
  if (unit_table != nullptr) {
    IColumn* name_column = unit_table->GetColumnByBaseName("name");
    if (name_column != nullptr) {
      name_column->CaseSensitive(true);
    }
  }

  ITable* dim_table = GetTableByBaseId(BaseId::AoPhysicalDimension);
  if (dim_table != nullptr) {
    IColumn* name_column = dim_table->GetColumnByBaseName("name");
    if (name_column != nullptr) {
      name_column->CaseSensitive(true);
    }
  }
  if (Modified() == 0) {
    try {
      std::filesystem::path file(filename);
      const auto last = std::filesystem::last_write_time(file);
      const auto ns1970 = util::time::FileTimeToNs(last);
      Modified(ns1970);
    } catch (const std::exception& ) {
    }
  }
  if (Created() == 0) {
    Created(Modified());
  }

  const auto& env_type = xml_file->Property("SourceEnvType", std::string());
  if (SourceType().empty() && !env_type.empty()) {
    SourceType(env_type);
  }

  IXmlNode::ChildList node_list;
  xml_file->GetChildList(node_list);

  // Read in all enumerations first and then the tables
  for (const auto* node : node_list) {
    if (node == nullptr) {
      continue;
    }
    if (node->IsTagName("Enum") || node->IsTagName("Enumerate")) {
      ReadEnum(*node);
    } else if (node->IsTagName("EnumList")) {
       IXmlNode::ChildList enum_list;
       node->GetChildList(enum_list);
       for (const auto& node1 : enum_list) {
         if (node1->IsTagName("Enum") || node1->IsTagName("Enumerate")) {
           ReadEnum(*node1);
         }
       }
    } else if (node->IsTagName("RelationList")) {
      IXmlNode::ChildList relation_node_list;
      node->GetChildList(relation_node_list);
      for (const auto* relation_node : relation_node_list) {
        if (relation_node == nullptr) {
          continue;
        }
        if (relation_node->IsTagName("Relation") ) {
          ReadRelation(*relation_node);
        }
      }
    }
  }

  for (const auto* node_table : node_list) {
    if (node_table == nullptr) {
      continue;
    }
    if (node_table->IsTagName("Element") || node_table->IsTagName("Table")) {
      ReadTable(*node_table);
    }
  }
  return true;
}

void IModel::ReadEnum(const IXmlNode &node) {
  IEnum obj;
  if (node.ExistProperty("EnumName")) {
    obj.EnumName(node.Property<std::string>("EnumName"));
  } else {
    obj.EnumName(node.Attribute<std::string>("name"));
  }

  if (node.ExistProperty("Locked")) {
    obj.Locked(node.Property<bool>("Locked"));
  } else {
    obj.Locked(node.Attribute<bool>("locked"));
  }

  IXmlNode::ChildList item_list;
  node.GetChildList(item_list);
  for (const auto& item : item_list) {
    if (!item->IsTagName("Item")) {
      continue;
    }
    const int64_t item_no = item->ExistProperty("ItemNo") ?
        item->Property<int64_t>("ItemNo") : item->Attribute<int64_t>("number");
    const std::string item_text = item->ExistProperty("ItemName") ?
        item->Property<std::string>("ItemName") : item->Attribute<std::string>("value");
     obj.AddItem(item_no, item_text);
  }
  AddEnum(obj);
}

void IModel::ReadRelation(const IXmlNode &node) {
  IRelation relation;

  if (node.ExistProperty("Name")) {
    relation.Name(node.Property<std::string>("Name"));
  } else {
    relation.Name(node.Attribute<std::string>("name"));
  }

  if (node.ExistProperty("ApplicationId1")) {
    relation.ApplicationId1(node.Property<int>("ApplicationId1"));
  } else {
    const auto table_name = node.Attribute<std::string>("table1");
    const auto* table = GetTableByName(table_name);
    if (table != nullptr) {
      relation.ApplicationId1(table->ApplicationId());
    }
  }
  if (node.ExistProperty("ApplicationId2")) {
    relation.ApplicationId2(node.Property<int>("ApplicationId2"));
  } else {
    const auto table_name = node.Attribute<std::string>("table2");
    const auto* table = GetTableByName(table_name);
    if (table != nullptr) {
      relation.ApplicationId2(table->ApplicationId());
    }
  }
  relation.DatabaseName( node.Property<std::string>("DatabaseName") );
  relation.InverseName( node.Property<std::string>("InverseName") );
  relation.BaseName( node.Property<std::string>("BaseName") );
  relation.InverseBaseName( node.Property<std::string>("InverseName") );

  if (relation.Name().empty()) {
    return;
  }
  auto exist = relation_list_.find(relation.Name());
  if (exist == relation_list_.end()) {
    relation_list_.emplace(relation.Name(), relation);
  } else {
    exist->second = relation;
  }
}



void IModel::ReadTable(const IXmlNode &node) {
  ITable table;
  if (node.ExistProperty("Id")) {
    table.ApplicationId(node.Property<int64_t>("Id"));
  } else {
    table.ApplicationId(node.Attribute<int64_t>("id"));
  }

  if (node.ExistProperty("ParentId")) {
    table.ParentId(node.Property<int64_t>("ParentId"));
  } else {
    table.ParentId(node.Attribute<int64_t>("parent"));
  }

  if (node.ExistProperty("BaseId")) {
    table.BaseId( TextToBaseId(node.Property<std::string>("BaseId")) );
  } else {
    table.BaseId( TextToBaseId(node.Attribute<std::string>("base")) );
  }

  if (node.ExistProperty("Name")) {
    table.ApplicationName(node.Property<std::string>("Name"));
  } else {
    table.ApplicationName(node.Attribute<std::string>("name"));
  }

  if (node.ExistProperty("TableName")) {
    table.DatabaseName(node.Property<std::string>("TableName"));
  } else {
    table.DatabaseName(node.Attribute<std::string>("table"));
  }
  IXmlNode::ChildList column_list;
  node.GetChildList(column_list);
  for (const auto& col : column_list) {
    if (col->IsTagName("Attribute")) {
      ::ReadColumn(*col, table);
    }
  }
  AddTable(table);
}

const ITable *IModel::GetTable(int64_t application_id) const {
  const auto itr = table_list_.find(application_id);
  if (itr != table_list_.cend()) {
    return &itr->second;
  }
  for (const auto& table : table_list_ ) {
    const auto* find = table.second.GetTable(application_id);
    if (find != nullptr) {
     return find;
    }
  }
  return nullptr;
}

const IEnum *IModel::GetEnum(const std::string& name) const {
  const auto itr = enum_list_.find(name);
  return itr == enum_list_.cend() ? nullptr : &itr->second;
}

IEnum *IModel::GetEnum(const std::string& name) {
  auto itr = enum_list_.find(name);
  return itr == enum_list_.cend() ? nullptr : &itr->second;
}

const ITable *IModel::GetTableByBaseId(BaseId base) const {
    // Search on top level first which is the normal case for this function
  const auto itr1 = std::ranges::find_if(table_list_, [&] (const auto& itr) {
    return itr.second.BaseId() == base;
  });
  if (itr1 != table_list_.cend()) {
    return &itr1->second;
  }
    // Plan B is to do a deep search
  for (const auto& itr2 : table_list_) {
    const auto* table = itr2.second.GetBaseId(base);
    if (table != nullptr) {
      return table;
    }
  }
  return nullptr;
}

ITable *IModel::GetTableByBaseId(BaseId base) {
  // Search on top level first which is the normal case for this function
  auto itr1 = std::ranges::find_if(table_list_, [&] (const auto& itr) -> bool {
    return itr.second.BaseId() == base;
  });

  if (itr1 != table_list_.end()) {
    return &itr1->second;
  }

  // Plan B is to do a deep search
  for (auto& [name, table] : table_list_) {
    ITable* sub_table = table.GetBaseId(base);
    if (sub_table != nullptr) {
      return sub_table;
    }
  }
  return nullptr;
}

const ITable *IModel::GetTableByName(const std::string &name) const {
  for (const auto& itr : table_list_) {
    const auto& table = itr.second;
    const auto* find = table.GetTableByName(name);
    if (find != nullptr) {
      return find;
    }
  }
  return GetTableByDbName(name);
}

const ITable *IModel::GetTableByDbName(const std::string &name) const {
  for (const auto& itr : table_list_) {
    const auto& table = itr.second;
    const auto* find = table.GetTableByDbName(name);
    if (find != nullptr) {
      return find;
    }
  }
  return nullptr;
}

int64_t IModel::FindNextTableId(int64_t parent_id) const {
  if (parent_id <= 0) {
    if (table_list_.empty()) {
      return 1;
    }
    for (int64_t table_id = 10; table_id < 10'000; table_id += 10) {
      const auto* exist = GetTable(table_id);
      if (exist == nullptr) {
        return table_id;
      }
    }
  }

  for (int64_t table_id = parent_id; table_id < (parent_id + 100); ++table_id) {
    const auto* exist = GetTable(table_id);
    if (exist == nullptr) {
      return table_id;
    }
  }
  for (int64_t table_id = 1; table_id < 1'000; ++table_id) {
    const auto* exist = GetTable(table_id);
    if (exist == nullptr) {
      return table_id;
    }
  }
  return 0;
}

bool IModel::DeleteTable(int64_t application_id) {
  for (auto itr = table_list_.begin(); itr != table_list_.end(); ++itr) {
    if (itr->second.ApplicationId() == application_id) {
      table_list_.erase(itr);
      return true;
    }
    const auto sub = itr->second.DeleteSubTable(application_id);
    if (sub) {
      return true;
    }
  }
  return false;
}

std::vector<const ITable*> IModel::AllTables() const {
  std::vector<const ITable*> temp_list;
  for (const auto& [table_name, table1] : table_list_) {
    if (table1.DatabaseName().empty()) {
      continue;
    }
    temp_list.emplace_back(&table1);
    AddSubTable(table1, temp_list);
  }

  // Need to sort the list so the referenced tables are created first
  std::vector<const ITable*> sorted_list;
  while (!temp_list.empty()) {
    size_t list_size = temp_list.size();
    for (auto itr1 = temp_list.begin();
         itr1 != temp_list.end();
         /* No ++ here*/ ) {
      const auto* table = *itr1;
      if (table == nullptr) {
        itr1 = temp_list.erase(itr1);
        continue;
      }
      bool ref_exist = false;
      const auto& column_list = table->Columns();
      for (const auto& column : column_list) {
         const auto ref_id = column.ReferenceId();
         if (ref_id == 0 || column.DatabaseName().empty()) {
           continue;
         }
         const auto exist = std::ranges::any_of(temp_list,
              [&] (const auto* ref_table) {
                 return ref_table != nullptr &&
                        ref_table->ApplicationId() == ref_id &&
                        ref_table->ApplicationId() != table->ApplicationId();
               });
         if (exist) {
           ref_exist = true;
           break;
         }
      } // End of for column

      if (ref_exist) {
         ++itr1; // Wait for the next iteration
      } else {
         sorted_list.emplace_back(*itr1);
         itr1 = temp_list.erase(itr1);
      }
    }

    // Remaining tables are top level table with no references
    if (temp_list.size() == list_size) {
      // Something is wrong in the model. Just add the remaining tables
      for (const auto* table2 : temp_list) {
        if (table2 == nullptr) {
           continue;
        }
        LOG_ERROR() << "Circular dependency detected. Model: " << Name()
        << ", Table: " << table2->ApplicationName();
        sorted_list.push_back(table2);
      }
      temp_list.clear();
    }
  }
  return sorted_list;
}

bool IModel::SaveModel(const std::string &filename) const {
  auto xml_file = CreateXmlFile("FileWriter");
  if (!xml_file) {
    LOG_ERROR() << "Failed to create the XML File. File: " << filename;
    return false;
  }
  xml_file->FileName(filename);
  auto &root = xml_file->RootName("OdsModel");
  xml_file->SetProperty("Version", 2);
  xml_file->SetProperty("Name", Name());
  xml_file->SetProperty("ApplicationVersion", Version());
  xml_file->SetProperty("Description", Description());
  xml_file->SetProperty("CreatedBy", CreatedBy());
  xml_file->SetProperty("ModifiedBy", ModifiedBy());
  xml_file->SetProperty("BaseVersion", BaseVersion());

  xml_file->SetProperty("Created", NsToIsoTime(Created()));
  xml_file->SetProperty("Modified", NsToIsoTime(Created()));

  xml_file->SetProperty("SourceName", SourceName());
  xml_file->SetProperty("SourceType", SourceType());
  xml_file->SetProperty("SourceInfo", SourceInfo());

  auto &enum_root = root.AddNode("EnumList");
  const auto &enum_list = Enums();
  for (const auto &enum1: enum_list) {
    SaveEnum(enum1.second, enum_root);
  }
  const auto table_list = AllTables();
  for (const auto *table: table_list) {
    if (table == nullptr) {
      continue;
    }
    SaveTable(*table, root);
  }

  if (!relation_list_.empty()) {
    auto &relation_root = root.AddNode("RelationList");
    for (const auto &[relation_name, relation]: relation_list_) {
      SaveRelation(relation, relation_root);
    }
  }

  return xml_file->WriteFile();
}

bool IModel::IsEmpty() const {
  return table_list_.empty();
}

int64_t IModel::FindNextEnumId() const {
  for (int64_t next = 1; next < static_cast<int64_t>(enum_list_.size() + 10); ++next) {
    const auto exist = std::ranges::any_of(enum_list_, [&] (const auto& itr) {
      return itr.second.EnumId() == next;
    });
    if (!exist) {
      return next;
    }
  }
  return 0;
}

void IModel::AddRelation(const IRelation& relation) {
  if (relation.Name().empty()) {
    return;
  }

  if (auto itr = relation_list_.find(relation.Name()); itr != relation_list_.end()) {
    itr->second = relation;
  } else {
    relation_list_.emplace(relation.Name(), relation );
  }
}

void IModel::DeleteRelation(const std::string &name) {
  if ( auto itr = relation_list_.find(name); itr != relation_list_.end()) {
    relation_list_.erase( itr );
  }
}

const IRelation *IModel::GetRelationByName(const std::string &name) const {
  const auto itr = relation_list_.find(name);
  return itr != relation_list_.cend() ? &itr->second : nullptr;
}


void IModel::SaveRelation(const IRelation& relation, IXmlNode &root) const {
  auto& node = root.AddNode("Relation");
  node.SetAttribute("name",relation.Name());

  const auto* table1 = GetTable(relation.ApplicationId1());
  if (table1 != nullptr) {
    node.SetAttribute("table1",table1->ApplicationName() );
  }

  const auto* table2 = GetTable(relation.ApplicationId2());
  if (table2 != nullptr) {
    node.SetAttribute("table2",table2->ApplicationName() );
  }
  node.SetProperty("Name", relation.Name() );
  node.SetProperty("ApplicationId1", relation.ApplicationId1() );
  node.SetProperty("ApplicationId2", relation.ApplicationId2() );
  node.SetProperty("DatabaseName", relation.DatabaseName() );
  node.SetProperty("InverseName", relation.InverseName() );
  node.SetProperty("BaseName", relation.BaseName() );
  node.SetProperty("InverseBaseName", relation.InverseBaseName() );
}

} // end namespace